<!DOCTYPE html>
<html lang="en">
  <meta charset="utf-8" />
  <title>Two-Point Cubic Hermite (slopes) — Canvas</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 16px;
    }
    label {
      display: inline-block;
      width: 90px;
    }
    input {
      width: 80px;
      margin: 2px 8px 8px 0;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 6px;
    }
  </style>
  <body>
    <div>
      <div>
        <label>P0.x</label><input id="x0" type="number" value="100" step="1" />
        <label>P0.y</label><input id="y0" type="number" value="300" step="1" />
        <label>m0 (dy/dx)</label
        ><input id="m0" type="number" value="-1" step="0.1" />
      </div>
      <div>
        <label>P1.x</label><input id="x1" type="number" value="500" step="1" />
        <label>P1.y</label><input id="y1" type="number" value="120" step="1" />
        <label>m1 (dy/dx)</label
        ><input id="m1" type="number" value="0.5" step="0.1" />
      </div>
      <div>
        <label>Scale</label
        ><input id="scale" type="number" value="0.3" step="0.05" />
        <button id="draw">Draw</button>
        <small>Scale is tangent length as a fraction of point distance.</small>
      </div>
    </div>
    <canvas id="c" width="700" height="420"></canvas>

    <script>
      /* Cubic Hermite with endpoint positions p0,p1 and endpoint slopes m0,m1 (dy/dx).
   We convert slopes to 2D tangent vectors T0, T1 with controllable magnitude. */

      function hermitePoint(p0, p1, T0, T1, t) {
        const t2 = t * t,
          t3 = t2 * t;
        const h00 = 2 * t3 - 3 * t2 + 1;
        const h10 = t3 - 2 * t2 + t;
        const h01 = -2 * t3 + 3 * t2;
        const h11 = t3 - t2;

        return {
          x: h00 * p0.x + h10 * T0.x + h01 * p1.x + h11 * T1.x,
          y: h00 * p0.y + h10 * T0.y + h01 * p1.y + h11 * T1.y,
        };
      }

      // Convert slope (dy/dx) to a tangent vector with chosen magnitude.
      // If slope is ±Infinity, use a pure vertical vector.
      function slopeToTangent(m, length) {
        if (!Number.isFinite(m)) return { x: 0, y: Math.sign(m) || 1 * length };
        const vx = 1,
          vy = m; // direction ~ (1, m)
        const norm = Math.hypot(vx, vy) || 1;
        const scale = length / norm;
        return { x: vx * scale, y: vy * scale };
      }

      function drawCurve(ctx, p0, p1, m0, m1, scaleFrac = 0.3) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // Tangent magnitudes proportional to distance between endpoints
        const d = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        const L = d * scaleFrac;
        const T0 = slopeToTangent(m0, L);
        const T1 = slopeToTangent(m1, L);

        // Guides: points and tangent rays
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#999";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Tangent arrows
        drawArrow(ctx, p0, { x: p0.x + T0.x, y: p0.y + T0.y }, "#aaa");
        drawArrow(ctx, p1, { x: p1.x + T1.x, y: p1.y + T1.y }, "#aaa");

        // Endpoints
        drawPoint(ctx, p0.x, p0.y, "#d33");
        drawPoint(ctx, p1.x, p1.y, "#36c");

        // Hermite curve
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#111";
        ctx.beginPath();
        const steps = 200;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const P = hermitePoint(p0, p1, T0, T1, t);
          if (i === 0) ctx.moveTo(P.x, P.y);
          else ctx.lineTo(P.x, P.y);
        }
        ctx.stroke();
      }

      function drawPoint(ctx, x, y, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawArrow(ctx, a, b, color) {
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        const angle = Math.atan2(b.y - a.y, b.x - a.x);
        const len = 8;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(
          b.x - len * Math.cos(angle - Math.PI / 6),
          b.y - len * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          b.x - len * Math.cos(angle + Math.PI / 6),
          b.y - len * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
      }

      // UI wiring
      const $ = (id) => document.getElementById(id);
      const ctx = $("c").getContext("2d");

      function readInputsAndDraw() {
        const p0 = { x: +$("x0").value, y: +$("y0").value };
        const p1 = { x: +$("x1").value, y: +$("y1").value };
        const m0 = +$("m0").value;
        const m1 = +$("m1").value;
        const scale = Math.max(0, +$("scale").value);
        drawCurve(ctx, p0, p1, m0, m1, scale);
      }

      $("draw").addEventListener("click", (e) => {
        e.preventDefault();
        readInputsAndDraw();
      });

      // initial render
      readInputsAndDraw();
    </script>
  </body>
</html>
